using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// Defines a <see cref="ICellGenerator"/> that is able to generate groups of cells in the shape of a table.
/// </summary>
public class TableCellGenerator : MonoBehaviour, ICellGenerator
{
    /// <summary>
    /// Whether the table of cells should be generated when the Start() is called.
    /// </summary>
    public bool generateOnStart = false;

    /// <summary>
    /// The size that the table should be. (x, y)
    /// </summary>
    public Vector2 size = new Vector2(10, 10);

    /// <summary>
    /// Gets the groups of cells that have been generated by this generator.
    /// </summary>
    public CellGroup[] generatedGroups
    {
        get { return _generatedGroups.ToArray(); }
    }

    /// <summary>
    /// The cells that should be created using this generator.
    /// </summary>
    public Cell[] prefabs = new Cell[0];

    private List<CellGroup> _generatedGroups = new List<CellGroup>();

    /// <summary>
    /// Generates a group of cells on demand.
    /// </summary>
    /// <returns>Returns a <see cref="CellGroup"/> object that represents the logical grouping of the cells.</returns>
    public CellGroup GenerateCells()
    {
        GameObject objectsGroup = new GameObject("Group " + _generatedGroups.Count);
        objectsGroup.transform.parent = this.transform;
        objectsGroup.transform.position = transform.InverseTransformPoint(new Vector3(0, 0));
        int xSize = (int)size.x;
        int ySize = (int)size.y;
        Cell[] cells = new Cell[xSize * ySize];
        Dictionary<Cell, Cell[]> siblingMap = new Dictionary<Cell, Cell[]>(xSize * ySize);

        for (var y = 0; y < (int)size.y; y++)
        {
            for (var x = 0; x < (int)size.x; x++)
            {
                Cell newCell = GenerateCell(x, y, objectsGroup.transform);
                if (y == 0 && x == 0)
                {
                    newCell.captured = true;
                }
                cells[(y * xSize) + x] = newCell;
            }
        }

        foreach (var cell in cells)
        {
            siblingMap.Add(cell, GetSiblingCells(cell).Where(c => c != null).ToArray());
        }

        CellGroup group = new CellGroup(cells, siblingMap);
        _generatedGroups.Add(group);
        return group;
    }

    private Cell GenerateCell(int x, int y, Transform parent)
    {
        GameObject prefab = prefabs[Random.Range(0, prefabs.Length)].gameObject;
        GameObject newObj = Instantiate(prefab);
        Transform trans = newObj.transform;
        trans.parent = parent;
        trans.position = parent.InverseTransformPoint(new Vector3(x, y));
        return trans.GetComponent<Cell>();
    }

    public IEnumerable<Cell> GetSiblingCells(Cell cell)
    {
        Transform cellTrans = cell.transform;
        Vector3 cellPos = cell.transform.position;
        yield return RaycastCell(cellPos, cellTrans.right);
        yield return RaycastCell(cellPos, -cellTrans.right);
        yield return RaycastCell(cellPos, cellTrans.up);
        yield return RaycastCell(cellPos, -cellTrans.up);
    }

    private Cell RaycastCell(Vector3 origin, Vector3 dir)
    {
        RaycastHit hit;
        if (Physics.Raycast(origin, dir, out hit, 1))
        {
            return hit.transform.GetComponent<Cell>();
        }
        return null;
    }

    void Start()
    {
        if (generateOnStart)
        {
            GenerateCells();
        }
    }
}
